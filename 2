use crate::{
    graph::LocationGraph,
    program::{AnnotProg, LiveInstruction, Location},
};
use syntax::x86::{Instruction, VarArg};

pub fn build_move_graph(prog: &AnnotProg) -> LocationGraph {
    let mut graph = LocationGraph::new();
    for (_, block) in prog.blocks.iter() {
        build_block(block, &mut graph);
    }
    graph
}

fn build_block(block: &[LiveInstruction], graph: &mut LocationGraph) {
    for instr in block.iter() {
        build_instr(instr, graph);
    }
}

fn build_instr(instr: &LiveInstruction, graph: &mut LocationGraph) {
    match &instr.instr {
        Instruction::MovQ {
            src: VarArg::Var(v1),
            dest: VarArg::Var(v2),
        } => graph.add_edge(
            Location::Variable(v1.clone()),
            Location::Variable(v2.clone()),
        ),
        _ => (),
    }
}

#[cfg(test)]
mod move_graph_tests {
    use super::AnnotProg;
    use syntax::x86::{Instruction, Reg};

    #[test]
    fn build_example() {
        let mut prog = AnnotProg::new();
        prog.add_block(
            "main",
            vec![
                Instruction::mov(1, "v"),
                Instruction::mov(42, "w"),
                Instruction::mov("v", "x"),
                Instruction::add(7, "x"),
                Instruction::mov("x", "y"),
                Instruction::mov("x", "z"),
                Instruction::add("w", "z"),
                Instruction::mov("y", "t"),
                Instruction::neg("t"),
                Instruction::mov("z", Reg::Rax),
                Instruction::add("t", Reg::Rax),
                Instruction::jmp("conclusion"),
            ],
        );
    }
}
